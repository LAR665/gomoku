<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>äº”å­æ£‹ - äººæœºå¯¹æˆ˜ç‰ˆ</title>
    <link rel="stylesheet" href="style.css">
    <style>
        body {
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            user-select: none;
        }

        h1 {
            color: #333;
            margin-bottom: 5px;
        }

        .controls {
            margin-bottom: 15px;
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .status {
            font-size: 18px;
            font-weight: bold;
            color: #d93a49;
            min-width: 120px;
            text-align: center;
        }

        canvas {
            background-color: #eebb77;
            box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.3);
            cursor: crosshair;
            border-radius: 4px;
        }

        button {
            padding: 8px 16px;
            font-size: 14px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }

        button.secondary {
            background-color: #6c757d;
        }

        button:hover {
            opacity: 0.9;
        }

        /* æ¨¡å¼åˆ‡æ¢å¼€å…³ */
        select {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
    </style>
</head>

<body>

    <h1>âš« ğŸ˜äº”å­æ£‹å¯¹å†³â¤ï¸ âšª</h1>
    <p><a href="rules.html" style="color: blue; text-decoration: underline;">æŸ¥çœ‹æ¸¸æˆè§„åˆ™</a></p>
    <div class="controls">
        <select id="modeSelect" onchange="restartGame()">
            <option value="pve">äººæœºæ¨¡å¼ (æŒ‘æˆ˜ç”µè„‘)</option>
            <option value="pvp">åŒäººæ¨¡å¼ (æœ‹å‹å¯¹æˆ˜)</option>
        </select>
        <div class="status" id="statusText">è½®åˆ°é»‘æ£‹</div>
        <button onclick="restartGame()">é‡æ–°å¼€å§‹</button>
    </div>

    <canvas id="chessBoard" width="450" height="450"></canvas>

    <script>
        const canvas = document.getElementById('chessBoard');
        const ctx = canvas.getContext('2d');
        const statusText = document.getElementById('statusText');
        const modeSelect = document.getElementById('modeSelect');

        // é…ç½®
        const gridSize = 30;
        const padding = 15;
        const boardSize = 15;

        let board = [];      // æ£‹ç›˜æ•°æ®
        let isBlackTurn = true; // true=é»‘(ç©å®¶), false=ç™½(ç”µè„‘/P2)
        let gameOver = false;
        let gameMode = 'pve'; // pve æˆ– pvp

        // åˆå§‹åŒ–
        function initBoard() {
            board = [];
            for (let i = 0; i < boardSize; i++) {
                board[i] = new Array(boardSize).fill(0);
            }
        }

        // ç»˜åˆ¶æ£‹ç›˜èƒŒæ™¯
        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = "#555";

            for (let i = 0; i < boardSize; i++) {
                ctx.beginPath();
                ctx.moveTo(padding, padding + i * gridSize);
                ctx.lineTo(padding + (boardSize - 1) * gridSize, padding + i * gridSize);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(padding + i * gridSize, padding);
                ctx.lineTo(padding + i * gridSize, padding + (boardSize - 1) * gridSize);
                ctx.stroke();
            }
        }

        // ç»˜åˆ¶æ£‹å­
        function drawPiece(x, y, role) { // role: 1é»‘ 2ç™½
            ctx.beginPath();
            let centerX = padding + x * gridSize;
            let centerY = padding + y * gridSize;
            ctx.arc(centerX, centerY, 13, 0, 2 * Math.PI);

            let gradient = ctx.createRadialGradient(centerX - 2, centerY - 2, 0, centerX, centerY, 13);
            if (role === 1) {
                gradient.addColorStop(0, "#666");
                gradient.addColorStop(1, "#000");
            } else {
                gradient.addColorStop(0, "#fff");
                gradient.addColorStop(1, "#ddd");
            }

            ctx.fillStyle = gradient;
            ctx.fill();

            // æ ‡è®°æœ€åä¸€æ‰‹ï¼Œæ–¹ä¾¿çœ‹æ¸…
            ctx.beginPath();
            ctx.arc(centerX, centerY, 3, 0, 2 * Math.PI);
            ctx.fillStyle = role === 1 ? "red" : "blue";
            ctx.fill();
        }

        // æ ¸å¿ƒï¼šèƒœè´Ÿåˆ¤æ–­
        function checkWin(x, y, role) {
            const directions = [
                [[0, 1], [0, -1]], [[1, 0], [-1, 0]],
                [[1, 1], [-1, -1]], [[1, -1], [-1, 1]]
            ];
            for (let axis of directions) {
                let count = 1;
                for (let dir of axis) {
                    let nx = x + dir[0], ny = y + dir[1];
                    while (nx >= 0 && nx < boardSize && ny >= 0 && ny < boardSize && board[nx][ny] === role) {
                        count++;
                        nx += dir[0];
                        ny += dir[1];
                    }
                }
                if (count >= 5) return true;
            }
            return false;
        }

        // --- ğŸ¤– ç”µè„‘ AI é€»è¾‘å¼€å§‹ ---
        function computerPlay() {
            if (gameOver) return;

            let maxScore = 0;
            let bestPoints = []; // å­˜å‚¨æœ€ä½³è½ç‚¹ï¼ˆå¯èƒ½æœ‰å¤šä¸ªï¼‰

            // éå†æ£‹ç›˜æ‰€æœ‰ç‚¹ï¼Œè®¡ç®—åˆ†æ•°
            for (let i = 0; i < boardSize; i++) {
                for (let j = 0; j < boardSize; j++) {
                    if (board[i][j] === 0) {
                        // è¯„ä¼°è¯¥ç‚¹ä»·å€¼ï¼š(æˆ‘æ–¹æ”¶ç›Š, æ•Œæ–¹å¨èƒ)
                        let score = evaluatePoint(i, j);

                        if (score > maxScore) {
                            maxScore = score;
                            bestPoints = [{ x: i, y: j }];
                        } else if (score === maxScore) {
                            bestPoints.push({ x: i, y: j });
                        }
                    }
                }
            }

            // å¦‚æœæœ‰å¤šä¸ªæœ€é«˜åˆ†ç‚¹ï¼Œéšæœºé€‰ä¸€ä¸ªï¼Œé¿å…AIèµ°æ³•å¤ªæ­»æ¿
            let move = bestPoints[Math.floor(Math.random() * bestPoints.length)];

            // å¦‚æœæ£‹ç›˜æ˜¯ç©ºçš„ï¼ˆç¬¬ä¸€æ‰‹ï¼‰ï¼Œä¸‹ä¸­é—´
            if (!move && board[7][7] === 0) move = { x: 7, y: 7 };

            if (move) {
                doMove(move.x, move.y, 2);
            }
        }

        // è¯„åˆ†å‡½æ•°ï¼šç»™å½“å‰ç‚¹æ‰“åˆ†
        function evaluatePoint(x, y) {
            let score = 0;
            // 1=é»‘(ç©å®¶), 2=ç™½(ç”µè„‘)
            // æ—¢è¦çœ‹å¯¹è‡ªå·±(2)æœ‰å¤šå¤§å¥½å¤„ï¼Œä¹Ÿè¦çœ‹å¯¹æ•Œäºº(1)æœ‰å¤šå¤§å¨èƒ
            score += calculateDirectionScore(x, y, 2); // è¿›æ”»åˆ†
            score += calculateDirectionScore(x, y, 1); // é˜²å®ˆåˆ†
            return score;
        }

        // è®¡ç®—æŸä¸ªæ–¹å‘ä¸Šçš„è¿å­æƒ…å†µåˆ†æ•°
        function calculateDirectionScore(x, y, role) {
            let totalScore = 0;
            const directions = [
                [[0, 1], [0, -1]], [[1, 0], [-1, 0]],
                [[1, 1], [-1, -1]], [[1, -1], [-1, 1]]
            ];

            for (let axis of directions) {
                let count = 1; // è¿å­æ•°
                let emptySide = 0; // ä¸¤å¤´æ˜¯å¦æœ‰ç©ºä½

                // å‘ä¸¤ä¸ªæ–¹å‘å»¶ä¼¸æ£€æŸ¥
                for (let dir of axis) {
                    let nx = x + dir[0], ny = y + dir[1];
                    // åªè¦è¿˜åœ¨æ£‹ç›˜å†…ä¸”é¢œè‰²ç›¸åŒ
                    while (nx >= 0 && nx < boardSize && ny >= 0 && ny < boardSize && board[nx][ny] === role) {
                        count++;
                        nx += dir[0];
                        ny += dir[1];
                    }
                    // æ£€æŸ¥å°½å¤´æ˜¯ä¸æ˜¯ç©ºä½
                    if (nx >= 0 && nx < boardSize && ny >= 0 && ny < boardSize && board[nx][ny] === 0) {
                        emptySide++;
                    }
                }

                // --- è¯„åˆ†è§„åˆ™ ---
                if (count >= 5) totalScore += 100000; // è¿äº”ï¼Œå¿…èƒœ/å¿…é˜²
                else if (count === 4 && emptySide === 2) totalScore += 10000; // æ´»å››ï¼Œæé«˜åˆ†
                else if (count === 4 && emptySide === 1) totalScore += 1000;  // å†²å››
                else if (count === 3 && emptySide === 2) totalScore += 1000;  // æ´»ä¸‰ï¼Œä¹Ÿå¾ˆå±é™©
                else if (count === 3 && emptySide === 1) totalScore += 100;   // çœ ä¸‰
                else if (count === 2 && emptySide === 2) totalScore += 50;    // æ´»äºŒ
            }
            return totalScore;
        }
        // --- ğŸ¤– ç”µè„‘ AI é€»è¾‘ç»“æŸ ---

        // æ‰§è¡Œè½å­
        function doMove(i, j, role) {
            board[i][j] = role;
            drawPiece(i, j, role);

            if (checkWin(i, j, role)) {
                setTimeout(() => {
                    let winner = role === 1 ? "é»‘æ£‹ (ä½ )" : "ç™½æ£‹ (ç”µè„‘)";
                    if (gameMode === 'pvp') winner = role === 1 ? "é»‘æ£‹" : "ç™½æ£‹";
                    alert(winner + " è·èƒœï¼ğŸ‰");
                }, 10);
                gameOver = true;
                statusText.innerText = "æ¸¸æˆç»“æŸ";
                return;
            }

            // åˆ‡æ¢å›åˆ
            isBlackTurn = !isBlackTurn;
            updateStatus();

            // å¦‚æœæ˜¯äººæœºæ¨¡å¼ï¼Œä¸”è½®åˆ°ç™½æ£‹(ç”µè„‘)ï¼Œåˆ™è§¦å‘AI
            if (gameMode === 'pve' && !isBlackTurn && !gameOver) {
                statusText.innerText = "ç”µè„‘æ€è€ƒä¸­...";
                // å»¶è¿Ÿä¸€ä¸‹ï¼Œè®©ç©å®¶æ„Ÿè§‰ç”µè„‘åœ¨â€œæ€è€ƒâ€
                setTimeout(computerPlay, 300);
            }
        }

        function updateStatus() {
            if (gameOver) return;
            if (gameMode === 'pve') {
                statusText.innerText = isBlackTurn ? "è½®åˆ°ä½  (é»‘)" : "ç”µè„‘æ€è€ƒä¸­...";
            } else {
                statusText.innerText = isBlackTurn ? "è½®åˆ°é»‘æ£‹" : "è½®åˆ°ç™½æ£‹";
                statusText.style.color = isBlackTurn ? "#000" : "#999";
            }
        }

        // ç©å®¶ç‚¹å‡»äº‹ä»¶
        canvas.onclick = function (e) {
            if (gameOver) return;
            // å¦‚æœæ˜¯äººæœºæ¨¡å¼ä¸”è½®åˆ°ç”µè„‘ï¼Œç¦æ­¢ç©å®¶ç‚¹å‡»
            if (gameMode === 'pve' && !isBlackTurn) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const i = Math.round((x - padding) / gridSize);
            const j = Math.round((y - padding) / gridSize);

            if (i < 0 || i >= boardSize || j < 0 || j >= boardSize || board[i][j] !== 0) return;

            doMove(i, j, 1); // ç©å®¶å§‹ç»ˆæ˜¯ 1 (é»‘)
            if (gameMode === 'pvp') doMove(i, j, isBlackTurn ? 1 : 2); // PVPé€»è¾‘ä¸åŒï¼Œè¿™é‡Œç®€å•å¤„ç†ï¼Œå®é™…ä¸ŠPVPéœ€è¦ä¿®æ”¹doMoveè°ƒç”¨æ–¹å¼ï¼Œä¸ºäº†ä»£ç ç®€æ´ï¼Œä¸Šé¢doMoveå·²ç»åŒ…å«äº†åˆ‡æ¢é€»è¾‘ï¼Œè¿™é‡Œåªéœ€è§¦å‘ç¬¬ä¸€æ­¥ã€‚
            // ä¿®æ­£ï¼šä¸Šé¢çš„doMoveè°ƒç”¨åœ¨PVPå’ŒPVEç¨å¾®æœ‰ç‚¹å†²çªï¼Œä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ä»¬åªåœ¨PVEæ¨¡å¼è°ƒç”¨doMove(i,j,1)ã€‚
            // åœ¨PVPæ¨¡å¼ä¸‹ï¼š
            if (gameMode === 'pvp') {
                // å›æ’¤ä¸Šé¢çš„ doMove(i,j,1) è°ƒç”¨ï¼Œé‡æ–°å†™ä¸€ä¸ªé€šç”¨çš„é€»è¾‘ï¼š
                // æŠ±æ­‰ï¼Œä¸ºäº†é€»è¾‘æ¸…æ™°ï¼Œæˆ‘ä»¬é‡å†™ä¸€ä¸‹ç‚¹å‡»é€»è¾‘ï¼š
            }
        };

        // ä¿®æ­£åçš„ç‚¹å‡»äº‹ä»¶
        canvas.onclick = function (e) {
            if (gameOver) return;

            // PVEæ¨¡å¼ï¼šè½®åˆ°ç”µè„‘æ—¶ç‚¹ä¸åŠ¨
            if (gameMode === 'pve' && !isBlackTurn) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const i = Math.round((x - padding) / gridSize);
            const j = Math.round((y - padding) / gridSize);

            if (i < 0 || i >= boardSize || j < 0 || j >= boardSize || board[i][j] !== 0) return;

            // ç¡®å®šå½“å‰è½å­è§’è‰²
            let role = 1; // é»˜è®¤é»‘æ£‹
            if (gameMode === 'pvp') {
                role = isBlackTurn ? 1 : 2;
            }

            doMove(i, j, role);
        };

        function restartGame() {
            gameMode = modeSelect.value;
            initBoard();
            isBlackTurn = true;
            gameOver = false;
            drawBoard();
            updateStatus();
        }

        // å¯åŠ¨
        restartGame();

    </script>
</body>

</html>